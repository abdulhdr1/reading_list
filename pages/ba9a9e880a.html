<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Mode: the better way to use MCP</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #f7f5f2; --fg: #1a1a1a; --fg2: #8a8578;
  --fg3: #b5ae9e; --border: #e5e2dc; --pill-bg: #eae7e1; --pill-fg: #6b6560;
}
[data-theme="dark"] {
  --bg: #1a1917; --fg: #e8e6e2; --fg2: #8a8578;
  --fg3: #5a5650; --border: #2e2c28; --pill-bg: #2e2c28; --pill-fg: #a09a90;
}
body {
  background: var(--bg); color: var(--fg);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  line-height: 1.7; transition: background .3s, color .3s;
  -webkit-font-smoothing: antialiased;
}
.container { max-width: 680px; margin: 0 auto; padding: 100px 24px 140px; }
.back {
  color: var(--fg2); text-decoration: none; font-size: 0.85rem;
  display: inline-block; margin-bottom: 48px; transition: opacity .2s;
  letter-spacing: 0.03em;
}
.back:hover { opacity: 0.5; }
h1 {
  font-family: 'Playfair Display', Georgia, serif; font-size: 2.8rem;
  font-weight: 900; letter-spacing: -0.03em; line-height: 1.1; margin-bottom: 16px;
}
.date { color: var(--fg2); font-size: 0.82rem; margin-bottom: 28px; letter-spacing: 0.03em; }
.visit {
  display: inline-block; padding: 10px 24px; border: 1.5px solid var(--border);
  border-radius: 24px; color: var(--fg); text-decoration: none; font-size: 0.88rem;
  margin-bottom: 40px; transition: all .2s; letter-spacing: 0.02em;
}
.visit:hover { background: var(--pill-bg); border-color: var(--fg3); }
.summary {
  color: var(--fg); font-size: 1.05rem; line-height: 1.8; margin-bottom: 40px;
  font-family: 'Inter', -apple-system, sans-serif;
}
.divider {
  width: 40px; height: 1.5px; background: var(--border); margin-bottom: 24px;
}
.tags { display: flex; flex-wrap: wrap; gap: 8px; }
.pill {
  background: var(--pill-bg); color: var(--pill-fg);
  font-size: 0.7rem; font-family: 'Inter', sans-serif; font-weight: 500;
  padding: 4px 12px; border-radius: 14px; white-space: nowrap;
  text-decoration: none; transition: all .2s; letter-spacing: 0.02em;
}
.pill:hover { background: var(--fg); color: var(--bg); }
.theme-toggle {
  position: fixed; top: 24px; right: 24px; background: none; border: none;
  font-size: 1.3rem; cursor: pointer; opacity: 0.4; transition: opacity .2s; z-index: 10;
}
.theme-toggle:hover { opacity: 1; }
@media (max-width: 480px) { .container { padding: 60px 20px 100px; } h1 { font-size: 2rem; } }
</style>
</head>
<body>
<button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">‚òÄÔ∏è</button>
<div class="container">
  <a class="back" href="../index.html">‚Üê Back to list</a>
  <h1>Code Mode: the better way to use MCP</h1>
  <div class="date">12/10/2025 - 16:56</div>
  <a class="visit" href="https://blog.cloudflare.com/code-mode/" target="_blank" rel="noopener">Visit original ‚Üó</a>
  <p class="summary">Cloudflare&#x27;s engineering team (Kenton Varda and Sunil Pai) discovered that the standard way everyone uses MCP (Model Context Protocol) is suboptimal ‚Äî and possibly fundamentally wrong. Instead of exposing tools directly to the LLM for function calling, they convert MCP tools into a TypeScript API and ask the LLM to write code that calls that API.

The results are striking for two reasons:

1) LLMs handle far more tools, and more complex tools, when presented as TypeScript interfaces. This is because LLMs have trained on enormous amounts of real-world TypeScript, but only on a small set of contrived tool-call examples. Tool calling relies on special tokens the LLM has rarely seen in the wild ‚Äî they must be specially trained via synthetic data. Code, on the other hand, is something LLMs have seen billions of lines of.

2) The approach dramatically improves multi-step workflows. With traditional tool calling, the output of each call feeds back through the LLM&#x27;s neural network just to be copied to the next call input ‚Äî wasting time, energy, and tokens. When the LLM writes code, it chains calls directly in a single execution, only reading back final results.

The article dives deep into how tool calling actually works under the hood: special non-textual tokens that signal &#x27;tool call start&#x27; and &#x27;tool call end,&#x27; JSON payloads between them, the harness pausing execution, and results fed back via another set of special tokens. It explains why MCP server designers are encouraged to present simplified APIs ‚Äî because LLMs struggle with complex tool schemas ‚Äî and how Code Mode removes that limitation entirely.

In short: LLMs are better at writing code to call MCP than at calling MCP directly. The implications for how we design agent architectures are significant.</p>
  <div class="divider"></div>
  <div class="tags"><a class="pill" href="../index.html?tag=ai">ai</a><a class="pill" href="../index.html?tag=engineering">engineering</a><a class="pill" href="../index.html?tag=frontend">frontend</a></div>
</div>
<script>
function toggleTheme() {
  const d = document.documentElement;
  const next = d.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  d.setAttribute('data-theme', next);
  document.querySelector('.theme-toggle').textContent = next === 'dark' ? 'üåô' : '‚òÄÔ∏è';
  localStorage.setItem('theme', next);
}
(function() {
  const saved = localStorage.getItem('theme') ||
    (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
  if (saved === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
    document.querySelector('.theme-toggle').textContent = 'üåô';
  }
})();
</script>
</body>
</html>