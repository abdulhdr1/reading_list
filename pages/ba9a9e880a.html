<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Mode: the better way to use MCP</title>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg: #ffffff; --text: #1a1a1a; --text-secondary: #6b6b6b;
  --border: #e8e5e1; --hover: #f5f4f2; --active-tag: #eeebe7; --badge: #c5c0b8;
}
[data-theme="dark"] {
  --bg: #141312; --text: #e8e6e2; --text-secondary: #8a8680;
  --border: #2a2826; --hover: #1f1e1c; --active-tag: #2a2826; --badge: #5a5650;
}
body {
  background: var(--bg); color: var(--text);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  line-height: 1.7; letter-spacing: -0.01em;
  -webkit-font-smoothing: antialiased;
}
.container { max-width: 640px; margin: 0 auto; padding: 80px 24px 120px; }
.back {
  color: var(--text-secondary); text-decoration: none; font-size: 13px;
  display: inline-flex; align-items: center; gap: 6px;
  margin-bottom: 40px; transition: color 150ms;
}
.back:hover { color: var(--text); }
h1 {
  font-size: 28px; font-weight: 600; letter-spacing: -0.02em;
  line-height: 1.2; margin-bottom: 12px;
}
.meta {
  display: flex; align-items: center; gap: 12px;
  color: var(--text-secondary); font-size: 13px; margin-bottom: 32px;
}
.meta-dot { color: var(--badge); }
.visit {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px;
  color: var(--text); text-decoration: none; font-size: 13px; font-weight: 450;
  margin-bottom: 32px; transition: background 150ms, border-color 150ms;
  font-family: inherit; letter-spacing: -0.01em;
}
.visit:hover { background: var(--hover); border-color: var(--badge); }
.summary {
  color: var(--text); font-size: 15px; line-height: 1.8; margin-bottom: 32px;
}
.divider { width: 32px; height: 1px; background: var(--border); margin-bottom: 20px; }
.tags { display: flex; flex-wrap: wrap; gap: 6px; }
.pill {
  background: var(--hover); color: var(--text-secondary);
  font-size: 12px; font-weight: 450; padding: 4px 10px; border-radius: 4px;
  text-decoration: none; transition: background 150ms; letter-spacing: -0.01em;
}
.pill:hover { background: var(--active-tag); color: var(--text); }
.theme-toggle {
  position: fixed; top: 20px; right: 20px; background: none; border: none;
  font-size: 14px; cursor: pointer; color: var(--text-secondary);
  opacity: 0.5; transition: opacity 150ms;
}
.theme-toggle:hover { opacity: 1; }
@media (max-width: 480px) {
  .container { padding: 60px 16px 80px; }
  h1 { font-size: 22px; }
}
</style>
</head>
<body>
<button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">‚òÄÔ∏è</button>
<div class="container">
  <a class="back" href="../index.html">‚Üê Back</a>
  <h1>Code Mode: the better way to use MCP</h1>
  <div class="meta">
    <span>12/10/2025 - 16:56</span>
    <span class="meta-dot">¬∑</span>
    <span>blog.cloudflare.com</span>
  </div>
  <a class="visit" href="https://blog.cloudflare.com/code-mode/" target="_blank" rel="noopener">Visit original ‚Üó</a>
  <p class="summary">Cloudflare&#x27;s engineering team (Kenton Varda and Sunil Pai) discovered that the standard way everyone uses MCP (Model Context Protocol) is suboptimal ‚Äî and possibly fundamentally wrong. Instead of exposing tools directly to the LLM for function calling, they convert MCP tools into a TypeScript API and ask the LLM to write code that calls that API.

The results are striking for two reasons:

1) LLMs handle far more tools, and more complex tools, when presented as TypeScript interfaces. This is because LLMs have trained on enormous amounts of real-world TypeScript, but only on a small set of contrived tool-call examples. Tool calling relies on special tokens the LLM has rarely seen in the wild ‚Äî they must be specially trained via synthetic data. Code, on the other hand, is something LLMs have seen billions of lines of.

2) The approach dramatically improves multi-step workflows. With traditional tool calling, the output of each call feeds back through the LLM&#x27;s neural network just to be copied to the next call input ‚Äî wasting time, energy, and tokens. When the LLM writes code, it chains calls directly in a single execution, only reading back final results.

The article dives deep into how tool calling actually works under the hood: special non-textual tokens that signal &#x27;tool call start&#x27; and &#x27;tool call end,&#x27; JSON payloads between them, the harness pausing execution, and results fed back via another set of special tokens. It explains why MCP server designers are encouraged to present simplified APIs ‚Äî because LLMs struggle with complex tool schemas ‚Äî and how Code Mode removes that limitation entirely.

In short: LLMs are better at writing code to call MCP than at calling MCP directly. The implications for how we design agent architectures are significant.</p>
  <div class="divider"></div>
  <div class="tags"><a class="pill" href="../index.html?tag=ai">ai</a><a class="pill" href="../index.html?tag=engineering">engineering</a><a class="pill" href="../index.html?tag=frontend">frontend</a></div>
</div>
<script>
function toggleTheme() {
  const d = document.documentElement;
  const next = d.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
  d.setAttribute('data-theme', next);
  document.querySelector('.theme-toggle').textContent = next === 'dark' ? 'üåô' : '‚òÄÔ∏è';
  localStorage.setItem('theme', next);
}
(function() {
  const saved = localStorage.getItem('theme') ||
    (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
  if (saved === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
    document.querySelector('.theme-toggle').textContent = 'üåô';
  }
})();
</script>
</body>
</html>